import os
import subprocess
import math
from collections import Counter as FrequencyCounter
import argparse
import sys
import re
from datetime import datetime as TimeStamp

try:
    import pefile as portable_executable
except ImportError:
    print("Problem: 'pefile' library missing.", file=sys.stderr)
    print("Solution: Install it using: pip install pefile", file=sys.stderr)
    sys.exit(1)

# --- Setup ---

HIGH_ENTROPY_LEVEL = 7.0
ALERT_THRESHOLD = 5

SIGNIFICANCE_SCORES = {
    "HIGH_ENTROPY": 2,
    "UNUSUAL_IMPORT": 1,
    "PECULIAR_SECTION": 2,
    "STRANGE_KEYWORD_STRING": 1,
    "COMMAND_LIKE_STRING": 2,
    "FILE_ENDING_PATTERN": 1,
    "NETWORK_ADDRESS_STRING": 1,
}

DOUBTFUL_LIBRARIES = {
    "rundll32.exe","advapi32.dll", "bcrypt.dll", "ncrypt.dll", "crypt32.dll", "wincrypt.h",
    "kernel32.dll", "shell32.dll", "shlwapi.dll", "ntdll.dll", "ole32.dll",
    "wininet32.dll", "winhttp.dll", "ws2_32.dll", "urlmon.dll", "httpapi.dll", "dnsapi.dll",
    "user32.dll",
    "shell32.dll",
    "gdi32.dll"
}

QUESTIONABLE_FUNCTIONS = {
    "LoadLibrary", "GetProcAddress",
    "FindFirstFile", "FindNextFile", "FindClose", "CreateFile", "ReadFile", "WriteFile",
    "DeleteFile", "RemoveDirectory", "SetFileAttributes", "GetLogicalDrives", "GetDriveType",
    "CryptAcquireContext", "CryptGenKey", "CryptEncrypt", "CryptDecrypt",
    "BCryptEncrypt", "BCryptGenRandom",
    "InternetOpen", "InternetConnect", "HttpOpenRequest", "HttpSendRequest",
    "WinHttpOpen", "WinHttpConnect", "WinHttpSendRequest",
    "socket", "connect", "send", "recv", "URLDownloadToFile",
    "OpenProcess", "VirtualAlloc", "VirtualAllocEx", "WriteProcessMemory", "ReadProcessMemory",
    "CreateRemoteThread", "AdjustTokenPrivileges", "OpenProcessToken",
    "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "NtQueryInformationProcess",
    "GetTickCount", "QueryPerformanceCounter", "RDTSC", "Sleep", "NtDelayExecution",
    "RegOpenKey", "RegSetValue", "RegCreateKey",
    "CreateService", "OpenService", "StartService", "CopyFile",
    "system", "ShellExecute", "CreateProcess",
    "DeleteVolumeMountPoint", "DeviceIoControl",
}

SUSPICIOUS_TEXT_SNIPPETS = [
    b"encrypt", b"decrypt", b"ransom", b"bitcoin", b"locked", b"wallet",
    b"recover", b"restore", b"attacked", b"hack", b"payment", b"deadline",
    b"contact", b"email", b"tor ", b".onion", b"AES", b"RSA", b"cipher",
    b"pay", b"disk", b"if", b"before", b"delete",
]

POTENTIAL_COMMANDS = [
    b"vssadmin delete shadows",
    b"bcdedit /set {default} recoveryenabled no",
    b"cipher /w",
    b"wmic.exe shadowcopy delete",
    b"wbadmin delete catalog",
    b"taskkill /f /im",
    b"net stop",
    b"wevtutil cl",
]

DUBIOUS_FILE_EXTENSIONS = [
    b".locked", b".encrypted", b".crypt", b".fun", b".payforunlock", b".enc",
    b".key", b".wallet", b".harma", b".wannacry", b".cerber", b".thor", b".locky",
    b".txt", b".doc", b".xls", b".pdf", b".jpg", b".png",
]

COMMON_PE_SECTIONS = {
    ".text", ".rdata", ".edata", ".tls",
    ".data", ".rodata", ".rsrc", ".pdata",
    ".bss", ".idata", ".reloc", ".CRT",
    ".code", ".DATA", ".BSS", ".reloc", ".CODE", ".gfids", ".giats", ".gljmp",
    ".orpc", ".shdata", ".srdata", ".stab", ".stabstr", ".sxdata", "_winmajor",
    "_winminor", "_major", "_minor",
}

# --- Analysis Procedures ---

def measure_information_disorder(file_location):
    """Computes the Shannon entropy of a file's contents."""
    try:
        with open(file_location, 'rb') as file_handle:
            byte_sequence = file_handle.read()
        if not byte_sequence:
            return 0.0, 0, ""

        file_size = len(byte_sequence)
        byte_frequencies = FrequencyCounter(byte_sequence)
        entropy_value = -sum(
            (freq / file_size) * math.log2(freq / file_size)
            for freq in byte_frequencies.values()
        )

        score_impact = 0
        indicator_message = ""
        if entropy_value >= HIGH_ENTROPY_LEVEL:
            score_impact = SIGNIFICANCE_SCORES["HIGH_ENTROPY"]
            indicator_message = f"Elevated Entropy ({entropy_value:.4f})"

        return entropy_value, score_impact, indicator_message

    except FileNotFoundError:
        print(f"Warning: File not found during entropy check: {file_location}", file=sys.stderr)
        return 0.0, 0, ""
    except Exception as e:
        print(f"Error during entropy calculation for {file_location}: {e}", file=sys.stderr)
        return 0.0, 0, ""

def scan_for_patterns(file_location):
    """Extracts strings and looks for suspicious patterns using the 'strings' utility."""
    pattern_score = 0
    found_patterns = []
    try:
        process = subprocess.run(['strings', '-a', file_location], capture_output=True, check=False, timeout=30)

        if process.returncode != 0 and process.stderr and b'supported format' not in process.stderr.lower():
            print(f"Warning: 'strings' returned code {process.returncode} for {file_location}. Error output: {process.stderr.decode(errors='ignore')}", file=sys.stderr)

        if process.stdout:
            text_output = process.stdout.lower()

            for keyword in SUSPICIOUS_TEXT_SNIPPETS:
                if keyword.lower() in text_output:
                    found_patterns.append(f"Keyword Match: {keyword.decode(errors='ignore')}")
                    pattern_score += SIGNIFICANCE_SCORES["STRANGE_KEYWORD_STRING"]

            for command in POTENTIAL_COMMANDS:
                if command.lower() in text_output:
                    found_patterns.append(f"Command Likelihood: {command.decode(errors='ignore')}")
                    pattern_score += SIGNIFICANCE_SCORES["COMMAND_LIKE_STRING"]

            extension_count = 0
            for extension in DUBIOUS_FILE_EXTENSIONS:
                if extension.lower() in text_output:
                    if extension_count < 5:
                        found_patterns.append(f"File Ending Clue: {extension.decode(errors='ignore')}")
                    pattern_score += SIGNIFICANCE_SCORES["FILE_ENDING_PATTERN"]
                    extension_count += 1
            if extension_count >= 5:
                found_patterns.append(f"Multiple ({extension_count}) File Ending Clues Found")

            ip_address_pattern = rb'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b'
            url_address_pattern = rb'https?://[^\s/$.?#].[^\s]*'
            onion_site_pattern = rb'[a-z2-7]{16,56}\.onion'

            ips_detected = re.findall(ip_address_pattern, process.stdout)
            urls_detected = re.findall(url_address_pattern, process.stdout, re.IGNORECASE)
            onions_detected = re.findall(onion_site_pattern, process.stdout, re.IGNORECASE)

            for ip in ips_detected[:3]:
                found_patterns.append(f"IP Address Found: {ip.decode(errors='ignore')}")
                pattern_score += SIGNIFICANCE_SCORES["NETWORK_ADDRESS_STRING"]
            for url in urls_detected[:3]:
                found_patterns.append(f"URL Found: {url.decode(errors='ignore')}")
                pattern_score += SIGNIFICANCE_SCORES["NETWORK_ADDRESS_STRING"]
            for onion in onions_detected[:3]:
                found_patterns.append(f"Onion Site Found: {onion.decode(errors='ignore')}")
                pattern_score += SIGNIFICANCE_SCORES["NETWORK_ADDRESS_STRING"] * 2

    except FileNotFoundError:
        print(f"Warning: 'strings' utility not found. Pattern analysis skipped for {file_location}.", file=sys.stderr)
    except subprocess.TimeoutExpired:
        print(f"Warning: 'strings' operation timed out for {file_location}.", file=sys.stderr)
    except Exception as e:
        print(f"Error executing 'strings' on {file_location}: {e}", file=sys.stderr)

    return pattern_score, found_patterns

def examine_pe_structure(file_path):
    """Analyzes PE files for unusual imports and sections using the pefile library."""
    pe_score = 0
    imported_functions = []
    named_sections = []
    is_executable_file = False

    try:
        pe_obj = portable_executable.PE(file_path, fast_load=True)
        is_executable_file = pe_obj.is_executable() or pe_obj.is_dll()

        if not is_executable_file:
            pe_obj.close()
            return 0, [], [], False

        pe_obj.parse_data_directories(directories=[portable_executable.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_IMPORT']])
        if hasattr(pe_obj, 'DIRECTORY_ENTRY_IMPORT'):
            for entry in pe_obj.DIRECTORY_ENTRY_IMPORT:
                library_name = entry.dll.decode('utf-8', errors='ignore').lower()
                for imp in entry.imports:
                    if imp.name:
                        function_name = imp.name.decode('utf-8', errors='ignore')
                        if function_name in QUESTIONABLE_FUNCTIONS:
                            imported_functions.append(f"Function: {function_name} (from {library_name})")
                            pe_score += SIGNIFICANCE_SCORES["UNUSUAL_IMPORT"]

        for section in pe_obj.sections:
            try:
                section_label = section.Name.decode('utf-8', errors='ignore').rstrip('\x00')
                if section_label and section_label not in COMMON_PE_SECTIONS:
                    named_sections.append(f"Name: {section_label}")
                    pe_score += SIGNIFICANCE_SCORES["PECULIAR_SECTION"]
            except Exception as e:
                print(f"Warning: Could not interpret section label in {file_path}: {e}", file=sys.stderr)

        pe_obj.close()

    except portable_executable.PEFormatError:
        is_executable_file = False
    except Exception as e:
        print(f"Error during PE file analysis of {file_path}: {e}", file=sys.stderr)
        pe_score = 0
        imported_functions = []
        named_sections = []

    return pe_score, imported_functions, named_sections, is_executable_file

def analyze_single_item(file_location):
    """Performs static analysis on a given file and returns an overall score and indicators."""
    print(f"\n--- Examining: {file_location} ---")
    total_score = 0
    identified_indicators = []

    try:
        if not os.path.isfile(file_location):
            print("  Problem: Not a valid file.", file=sys.stderr)
            return 0, []
        if not os.access(file_location, os.R_OK):
            print("  Problem: Cannot access file (permissions?).", file=sys.stderr)
            return 0, []

        entropy_value, entropy_score, entropy_indicator = measure_information_disorder(file_location)
        print(f"  Entropy Level: {entropy_value:.4f}")
        if entropy_indicator:
            identified_indicators.append(entropy_indicator)
            total_score += entropy_score

        pattern_score, string_indicators = scan_for_patterns(file_location)
        if string_indicators:
            print(f"  Suspicious Strings Found: {len(string_indicators)}")
            identified_indicators.extend(string_indicators)
            total_score += pattern_score

        pe_score, import_indicators, section_indicators, is_pe_file = examine_pe_structure(file_location)
        if is_pe_file:
            print("  Identified as Portable Executable (EXE/DLL)")
            if import_indicators:
                print(f"  Unusual Imports Found: {len(import_indicators)}")
                identified_indicators.extend(import_indicators)
            if section_indicators:
                print(f"  Peculiar Sections Found: {len(section_indicators)}")
                identified_indicators.extend(section_indicators)
            total_score += pe_score

    except Exception as e:
        print(f"  CRITICAL ERROR during file analysis of {file_location}: {e}", file=sys.stderr)
        return 0, [f"Analysis Error: {e}"]

    is_alarming = total_score >= ALERT_THRESHOLD
    analysis_result = "Positive" if is_alarming else "Negative"
    print(f"  Total Score: {total_score} (Threshold: {ALERT_THRESHOLD})")
    if identified_indicators:
        print("  Detected Indicators:")
        for indicator in identified_indicators[:10]:
            print(f"    - {indicator}")
        if len(identified_indicators) > 10:
            print(f"    - ... and {len(identified_indicators)-10} more.")
    else:
        print("  No specific indicators detected.")

    print(f"  Analysis Outcome: {analysis_result}")
    return total_score, identified_indicators

if __name__ == "__main__":
    argument_parser = argparse.ArgumentParser(
        description="Basic Anti-Ransomware Detector POC based on the 'Help For The Hopeless' document.",
        epilog="WARNING: Use only in controlled, isolated environments. Analysis results need careful interpretation and calibration."
    )
    argument_parser.add_argument("path", help="Path to the file or directory to analyze.")
    cmd_args = argument_parser.parse_args()

    input_path = cmd_args.path
    overall_suspicion = False
    items_examined = 0
    alarms_raised = 0

    if not os.path.exists(input_path):
        print(f"Error: Input path not found: {input_path}", file=sys.stderr)
        sys.exit(1)

    print("="*60)
    print(" Static Ransomware Detector POC")
    print(f" Time: {TimeStamp.now().strftime('%Y-%m-%d %H:%M:%S')}")
    print(f" Target: {os.path.abspath(input_path)}")
    print("="*60)

    if os.path.isfile(input_path):
        items_examined += 1
        score, indicators = analyze_single_item(input_path)
        if score >= ALERT_THRESHOLD:
            alarms_raised += 1
            overall_suspicion = True

    elif os.path.isdir(input_path):
        print(f"--- Scanning Directory (Recursive): {input_path} ---")
        for directory_root, _, file_list in os.walk(input_path):
            for filename in file_list:
                full_file_path = os.path.join(directory_root, filename)
                try:
                    items_examined += 1
                    score, indicators = analyze_single_item(full_file_path)
                    if score >= ALERT_THRESHOLD:
                        alarms_raised += 1
                        overall_suspicion = True
                except OSError as e:
                    print(f"  Problem accessing {full_file_path}: {e}", file=sys.stderr)
                except Exception as e:
                    print(f"  Unexpected issue analyzing {full_file_path}: {e}", file=sys.stderr)

    else:
        print(f"Error: Input path is not a valid file or directory: {input_path}", file=sys.stderr)
        sys.exit(1)

    print("\n" + "="*60)