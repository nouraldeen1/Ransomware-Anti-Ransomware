#!/usr/bin/env python3

import os
import sys
import math
import re
import time
import hashlib
from datetime import datetime
try:
    import pefile as portable_executable
    PE_SUPPORT = True
except ImportError:
    PE_SUPPORT = False
    print("Warning: pefile module not found. PE analysis features disabled.")

DETECTION_THRESHOLD = 10.5
MAX_STRING_SIZE = 50000

KEYWORD_WEIGHTS = {
    'extreme_risk': {
        'ransom': 8,
        'bitcoin': 8,
        'payment': 8,
        'btc': 8,
        'wallet': 8
    },
    'high_risk': {
        'pay': 3,
        'restore': 3
    },
    'medium_risk': {
        'encrypt': 0.3,
        'decrypt': 0.3,
        'recover': 0.3
    },
    'low_risk': {
        'locked': 0.2,
        'contact': 0.2
    }
}

FILE_EXTENSIONS = {
    '.enc': 1.5,
    '.locked': 1.5,
    '.crypto': 2,
    '.CRYPTED': 2,
    '.crypted': 2,
    '.vault': 1
}

BENIGN_EXTENSIONS = ['.doc', '.jpg', '.png', '.txt', '.xml', '.html', '.dll', '.exe']

entropy_values = {}

def get_entropy(file_path):
    """Calculate Shannon entropy of a file to detect encryption/compression."""
    with open(file_path, 'rb') as f:
        data = f.read(MAX_STRING_SIZE)
    if not data:
        return 0
    entropy = 0
    for byte_value in range(256):
        p_x = data.count(byte_value) / len(data)
        if p_x > 0:
            entropy += - p_x * math.log2(p_x)
    return entropy

def extract_strings(file_path, min_length=4):
    """Extract printable strings from binary file (ASCII and UTF-16)."""
    try:
        strings_list = []
        with open(file_path, 'rb') as f:
            data = f.read(MAX_STRING_SIZE)
        ascii_pattern = re.compile(b'[\x20-\x7E]{' + str(min_length).encode() + b',}')
        matches = ascii_pattern.findall(data)
        for match in matches:
            try:
                strings_list.append(match.decode('ascii', errors='ignore'))
            except Exception:
                pass
        utf16_pattern = re.compile(b'(?:[\x20-\x7E]\x00){' + str(min_length).encode() + b',}')
        utf16_matches = utf16_pattern.findall(data)
        for match in utf16_matches:
            try:
                strings_list.append(match.decode('utf-16le', errors='ignore'))
            except Exception:
                pass
        return strings_list
    except Exception as e:
        print(f"  Error extracting strings: {e}", file=sys.stderr)
        return []

def find_suspicious_keywords(strings_list):
    """Identify ransomware-related keywords in extracted strings."""
    found_keywords = []
    suspicious_contexts = []
    for string in strings_list:
        string_lower = string.lower()
        suspicious_phrases = [
            "files encrypted", "pay to decrypt", "bitcoin address",
            "payment instructions", "send money", "locked files",
            "recovery key", "your personal files", "cannot access files"
        ]
        for phrase in suspicious_phrases:
            if phrase in string_lower:
                suspicious_contexts.append(f"Suspicious phrase: {phrase}")
        for risk_level, keywords in KEYWORD_WEIGHTS.items():
            for keyword, weight in keywords.items():
                clean_keyword = keyword.replace('_', ' ')
                if clean_keyword in string_lower:
                    found_keywords.append(f"Keyword Match: {clean_keyword}")
    return found_keywords, suspicious_contexts

def extract_urls(strings_list):
    """Extract URLs from strings using regex pattern matching."""
    urls = []
    url_pattern = re.compile(r'https?://[^\s<>"\')]+')
    for string in strings_list:
        for url in url_pattern.findall(string):
            urls.append(url)
    return urls

def extract_ip_addresses(strings_list):
    """Extract and filter IPv4 addresses from strings."""
    ip_addresses = []
    ip_pattern = re.compile(r'\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b')
    for string in strings_list:
        for ip in ip_pattern.findall(string):
            if ip not in ["0.0.0.0", "127.0.0.1", "255.255.255.255"]:
                if re.match(r'^[1-9]\.0\.0\.0$', ip) or ip == "6.0.0.0":
                    continue
                if re.match(r'^\d\.\d+\.\d+\.\d+$', ip):
                    continue
                ip_addresses.append(ip)
    return ip_addresses

def find_file_extension_clues(strings_list):
    """Detect suspicious file extensions that may indicate encryption targets."""
    found_extensions = []
    for string in strings_list:
        for ext, weight in FILE_EXTENSIONS.items():
            if ext in string:
                found_extensions.append(f"File Extension Target: {ext}")
        for ext in BENIGN_EXTENSIONS:
            if ext in string:
                pass
    return found_extensions

def analyze_pe_file(file_path):
    """Analyze Portable Executable (PE) files for suspicious characteristics."""
    if not PE_SUPPORT:
        return 0, [], [], False
    pe_score = 0
    imported_functions = []
    named_sections = []
    is_executable_file = True
    import_count = 0
    
    extreme_risk_imports = [
        "CryptEncrypt", "CryptDecrypt"
    ]
    
    high_risk_imports = [
        "CreateProcessAsUserA", "FindNextFileNameW", "RealShellExecuteW",
        "CryptAcquireContextA", "WriteProcessMemory", "OpenProcess"
    ]
    
    medium_risk_imports = [
        "CreateProcessA", "DeleteFileW", "CopyFileA", "FindNextFileW",
        "SetFileAttributesW"
    ]
    
    low_risk_imports = [
        "QueryPerformanceCounter", "GetTickCount", "GetProcAddress",
        "Sleep", "WriteFile", "VirtualAlloc", "CreateFileW",
        "SetFilePointer", "CreateFileA", "LoadLibraryW",
        "IsDebuggerPresent", "GetTempPathW", "FindClose",
        "VirtualProtect", "CreateFileMappingA", "OpenProcessToken",
        "ReadFile", "VirtualAllocEx", "VirtualProtectEx",
        "InternetWriteFile", "InternetReadFile", "FindFirstFileW"
    ]

    extreme_risk_count = 0
    high_risk_count = 0
    medium_risk_count = 0
    low_risk_count = 0

    try:
        pe_obj = portable_executable.PE(file_path)
        if hasattr(pe_obj, 'DIRECTORY_ENTRY_IMPORT'):
            for entry in pe_obj.DIRECTORY_ENTRY_IMPORT:
                dll_name = entry.dll.decode('utf-8', errors='ignore').lower() if entry.dll else "unknown"
                for imp in entry.imports:
                    if imp.name:
                        import_count += 1
                        func_name = imp.name.decode('utf-8', errors='ignore')
                        for susp_import in extreme_risk_imports:
                            if susp_import in func_name:
                                imported_functions.append(f"{dll_name}:{func_name}")
                                extreme_risk_count += 1
                        for susp_import in high_risk_imports:
                            if susp_import in func_name:
                                imported_functions.append(f"{dll_name}:{func_name}")
                                high_risk_count += 1
                        for susp_import in medium_risk_imports:
                            if susp_import in func_name:
                                imported_functions.append(f"{dll_name}:{func_name}")
                                medium_risk_count += 1
                        for susp_import in low_risk_imports:
                            if susp_import in func_name:
                                imported_functions.append(f"{dll_name}:{func_name}")
                                low_risk_count += 1
        pe_score += extreme_risk_count * 8
        pe_score += high_risk_count * 3
        pe_score += medium_risk_count * 2
        pe_score += low_risk_count * 0.2
        for section in pe_obj.sections:
            section_name = section.Name.decode('utf-8', errors='ignore').strip('\x00')
            if section.Characteristics & 0xE0000000 == 0xE0000000:
                named_sections.append(f"{section_name} (Executable+Writable)")
                pe_score += 3
            section_data = section.get_data()
            if section_data:
                entropy = 0
                for byte_value in range(256):
                    p_x = section_data.count(bytes([byte_value])) / len(section_data)
                    if p_x > 0:
                        entropy += - p_x * math.log2(p_x)
                if entropy > 7.5:
                    named_sections.append(f"{section_name} (Extreme Entropy: {entropy:.4f})")
                    pe_score += 8
                elif entropy > 7.1:
                    named_sections.append(f"{section_name} (High Entropy: {entropy:.4f})")
                    pe_score += 3
        is_executable_file = False
        for section in pe_obj.sections:
            if section.Characteristics & 0x20000000:
                is_executable_file = True
                break
        if import_count < 10:
            pe_score += 2
            named_sections.append("Low Import Count (<10)")
        pe_obj.close()
    except portable_executable.PEFormatError:
        is_executable_file = False
    except Exception as e:
        print(f"  Error during PE file analysis of {file_path}: {e}", file=sys.stderr)
        pe_score = 0
        imported_functions = []
        named_sections = []
    return pe_score, imported_functions, named_sections, is_executable_file

def analyze_single_item(file_location):
    """Perform static analysis on a single file and return detection score."""
    print(f"\n--- Examining: {file_location} ---")
    total_score = 0
    identified_indicators = []
    try:
        if not os.path.isfile(file_location):
            print("  Problem: Not a valid file.", file=sys.stderr)
            return 0, []
        if not os.access(file_location, os.R_OK):
            print("  Problem: File not readable.", file=sys.stderr)
            return 0, []
        file_size = os.path.getsize(file_location)
        if file_size < 500000:  # 500 KB
            total_score += 2
            identified_indicators.append("Small File Size (<500 KB)")
        entropy = get_entropy(file_location)
        entropy_values[file_location] = entropy
        print(f"  Entropy Level: {entropy:.4f}")
        if entropy > 7.7:
            total_score += 3
            identified_indicators.append(f"Elevated Entropy ({entropy:.4f})")
        strings_list = extract_strings(file_location)
        found_keywords, suspicious_contexts = find_suspicious_keywords(strings_list)
        found_urls = extract_urls(strings_list)
        found_ips = extract_ip_addresses(strings_list)
        found_extensions = find_file_extension_clues(strings_list)
        pe_score, imported_functions, named_sections, is_executable = analyze_pe_file(file_location)
        identified_indicators.extend(found_keywords)
        identified_indicators.extend(suspicious_contexts)
        identified_indicators.extend([f"URL Found: {url}" for url in found_urls[:5]])
        identified_indicators.extend([f"IP Address Found: {ip}" for ip in found_ips[:5]])
        identified_indicators.extend(found_extensions)
        identified_indicators.extend([f"Suspicious Import: {imp}" for imp in imported_functions])
        identified_indicators.extend([f"Suspicious Section: {sec}" for sec in named_sections])
        keyword_score = 0
        for indicator in found_keywords:
            keyword = indicator.replace("Keyword Match: ", "")
            for risk_level, keywords in KEYWORD_WEIGHTS.items():
                for kw, weight in keywords.items():
                    clean_kw = kw.replace('_', ' ')
                    if clean_kw == keyword.lower():
                        keyword_score += weight
                        break
        total_score += keyword_score
        total_score += len(suspicious_contexts) * 4
        total_score += len(found_urls) * 0.1
        total_score += len(found_ips) * 0.5
        for ext_indicator in found_extensions:
            for ext, weight in FILE_EXTENSIONS.items():
                if ext in ext_indicator:
                    total_score += weight
        total_score += pe_score
        if len(identified_indicators) > 10:
            print(f"  Suspicious Strings Found: {len(identified_indicators)}")
            display_indicators = identified_indicators[:10]
            remaining = len(identified_indicators) - 10
            if remaining > 0:
                display_indicators.append(f"... and {remaining} more.")
        else:
            print(f"  Suspicious Strings Found: {len(identified_indicators)}")
            display_indicators = identified_indicators
        print(f"  Total Score: {total_score:.1f} (Threshold: {DETECTION_THRESHOLD})")
        if identified_indicators:
            print("  Detected Indicators:")
            for indicator in display_indicators:
                print(f"    - {indicator}")
        outcome = "Positive" if total_score >= DETECTION_THRESHOLD else "Negative"
        print(f"  Analysis Outcome: {outcome}")
        return total_score, identified_indicators
    except Exception as e:
        print(f"  Error analyzing {file_location}: {str(e)}", file=sys.stderr)
        return 0, []

def analyze_directory(directory_path, recursive=True):
    """Recursively scan and analyze all files in a directory."""
    print(f"--- Scanning Directory{' (Recursive)' if recursive else ''}: {directory_path} ---\n")
    positive_count = 0
    negative_count = 0
    total_files = 0
    try:
        for item in os.listdir(directory_path):
            full_path = os.path.join(directory_path, item)
            if os.path.isfile(full_path):
                score, _ = analyze_single_item(full_path)
                total_files += 1
                if score >= DETECTION_THRESHOLD:
                    positive_count += 1
                else:
                    negative_count += 1
            elif os.path.isdir(full_path) and recursive:
                sub_pos, sub_neg, sub_total = analyze_directory(full_path, recursive)
                positive_count += sub_pos
                negative_count += sub_neg
                total_files += sub_total
        if total_files > 0:
            print(f"\n--- Directory Summary: {directory_path} ---")
            print(f"  Total Files Analyzed: {total_files}")
            print(f"  Positive Detections: {positive_count} ({(positive_count/total_files)*100:.1f}%)")
            print(f"  Negative Detections: {negative_count} ({(negative_count/total_files)*100:.1f}%)\n")
        return positive_count, negative_count, total_files
    except PermissionError:
        print(f"Permission denied when accessing: {directory_path}", file=sys.stderr)
        return 0, 0, 0
    except Exception as e:
        print(f"Error scanning directory {directory_path}: {str(e)}", file=sys.stderr)
        return 0, 0, 0

def print_entropy_summary():
    """Display summary of file entropy analysis results."""
    if not entropy_values:
        return
    print("\n============================================================")
    print(" Entropy Analysis Summary")
    print("============================================================")
    sorted_files = sorted(entropy_values.items(), key=lambda x: x[1], reverse=True)
    for file_path, entropy in sorted_files:
        base_name = os.path.basename(file_path)
        print(f"  {base_name:30s}: {entropy:.4f}")
    avg_entropy = sum(entropy_values.values()) / len(entropy_values)
    print("\n  Average Entropy: {:.4f}".format(avg_entropy))
    print("============================================================")

def main():
    """Main entry point for the ransomware detection script."""
    print("============================================================")
    print(" Static Ransomware Detector POC")
    print(f" Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    if len(sys.argv) < 2:
        print("Usage: python static_detector.py <file_or_directory_path>")
        sys.exit(1)
    target_path = sys.argv[1]
    print(f" Target: {os.path.abspath(target_path)}")
    print("============================================================")
    if not os.path.exists(target_path):
        print(f"Error: The path '{target_path}' does not exist.", file=sys.stderr)
        sys.exit(1)
    if os.path.isfile(target_path):
        score, _ = analyze_single_item(target_path)
        result = "Positive" if score >= DETECTION_THRESHOLD else "Negative"
        print(f"\nFinal Result: {result}")
        print_entropy_summary()
    elif os.path.isdir(target_path):
        pos, neg, total = analyze_directory(target_path, recursive=True)
        print("============================================================")
        print(" Final Analysis Summary")
        print(f" Total Files Analyzed: {total}")
        if total > 0:
            pos_percent = (pos/total)*100 if total > 0 else 0
            neg_percent = (neg/total)*100 if total > 0 else 0
            print(f" Positive Detections: {pos} ({pos_percent:.1f}% of files)")
            print(f" Negative Detections: {neg} ({neg_percent:.1f}% of files)")
        else:
            print(" No files were analyzed.")
        print("============================================================")
        print_entropy_summary()
    else:
        print(f"Error: The path '{target_path}' is neither a file nor a directory.", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()