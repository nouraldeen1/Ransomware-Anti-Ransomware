#!/usr/bin/env python3

import os
import subprocess
import math
from collections import Counter as FrequencyCounter
import argparse
import sys
import re
import time
import hashlib
from datetime import datetime

# Third-party imports with error handling
try:
    import pefile as portable_executable
    PE_SUPPORT = True
except ImportError:
    PE_SUPPORT = False
    print("Warning: pefile module not found. PE analysis features disabled.")

# Constants and configuration
DETECTION_THRESHOLD = 8  # Increased from 5 to reduce false positives
MAX_STRING_SIZE = 50000  # Limit on file size for string extraction

# Suspicious keyword categories with weights
KEYWORD_WEIGHTS = {
    # High-risk keywords (specific to ransomware)
    'high_risk': {
        'ransom': 3,
        'decrypt_instruction': 3,
        'your_files_encrypted': 3,
        'bitcoin_address': 3,
        'payment_instruction': 3
    },
    
    # Medium-risk keywords (suspicious but may have legitimate uses)
    'medium_risk': {
        'encrypt': 2,
        'decrypt': 2,
        'bitcoin': 2,
        'wallet': 1,
        'payment': 1,
        'btc': 2
    },
    
    # Low-risk keywords (often found in legitimate software too)
    'low_risk': {
        'locked': 0.5,
        'recover': 0.5,
        'pay': 0.5,
        'restore': 0.5,
        'hack': 1,
        'contact': 0.5,
        'email': 0.5  
    }
}

# Common legitimate contexts that should NOT trigger detection
BENIGN_CONTEXTS = [
    'if', 'delete', 'before', 'disk', 'AES', 'RSA', 'cipher', 'tor',  # Common programming terms
    'http://schemas.microsoft.com', 'crl.microsoft.com',              # Common Microsoft URLs
    'http://www.gnu.org', 'https://www.gnu.org',                      # GNU URLs
    'ocsp.thawte.com', 'crl.thawte.com'                               # Certificate URLs
]

# File extension patterns that might indicate ransomware activity
FILE_EXTENSIONS = {
    '.enc': 1.5,
    '.locked': 1.5,
    '.crypto': 2,
    '.CRYPTED': 2,
    '.crypted': 2,
    '.vault': 1
}

# Legitimate file extensions commonly found in strings (reduce false positives)
BENIGN_EXTENSIONS = ['.doc', '.jpg', '.png', '.txt', '.xml', '.html', '.dll', '.exe']

# Functions for file analysis
def get_entropy(file_path):
    """Calculate Shannon entropy of a file to detect encryption or compression."""
    with open(file_path, 'rb') as f:
        data = f.read(MAX_STRING_SIZE)  # Limit reading for large files
    
    if not data:
        return 0
    
    # Calculate entropy
    entropy = 0
    for byte_value in range(256):
        p_x = data.count(byte_value) / len(data)
        if p_x > 0:
            entropy += - p_x * math.log2(p_x)
    
    return entropy

def extract_strings(file_path, min_length=4):
    """Extract printable strings from a binary file."""
    try:
        strings_list = []
        with open(file_path, 'rb') as f:
            data = f.read(MAX_STRING_SIZE)
            
        # ASCII strings
        ascii_chars = re.compile(b'[\x20-\x7E]{' + str(min_length).encode() + b',}')
        strings_list.extend([match.decode('ascii', errors='ignore') for match in ascii_chars.finditer(data)])
        
        # UTF-16 strings (common in Windows executables)
        utf16_chars = re.compile(b'(?:[\x20-\x7E]\x00){' + str(min_length).encode() + b',}')
        utf16_strings = []
        for match in utf16_chars.finditer(data):
            try:
                utf16_strings.append(match.group().decode('utf-16le', errors='ignore'))
            except UnicodeDecodeError:
                pass
                
        strings_list.extend(utf16_strings)
        return strings_list
    except Exception as e:
        print(f"  Error extracting strings: {e}", file=sys.stderr)
        return []

def find_suspicious_keywords(strings_list):
    """Identify suspicious keywords in strings with context awareness."""
    found_keywords = []
    suspicious_contexts = []
    
    # First pass: check for keywords
    for string in strings_list:
        string_lower = string.lower()
        
        # Check for suspicious phrases (stronger indicators)
        suspicious_phrases = [
            "files encrypted", "pay to decrypt", "bitcoin address",
            "payment instructions", "send money", "locked files",
            "recovery key", "your personal files", "cannot access files"
        ]
        
        for phrase in suspicious_phrases:
            if phrase in string_lower:
                suspicious_contexts.append(f"Suspicious phrase: {phrase}")
                
        # Check individual keywords
        for risk_level, keywords in KEYWORD_WEIGHTS.items():
            for keyword, weight in keywords.items():
                clean_keyword = keyword.replace('_', ' ')
                if clean_keyword in string_lower:
                    # Check if the keyword appears in a suspicious context
                    # and not just as a common programming term
                    is_benign_context = False
                    for benign in BENIGN_CONTEXTS:
                        # Skip if this is a common programming construct
                        if benign == clean_keyword:
                            is_benign_context = True
                            break
                    
                    if not is_benign_context:
                        found_keywords.append(f"Keyword Match: {clean_keyword}")
    
    return found_keywords, suspicious_contexts

def extract_urls(strings_list):
    """Extract URLs from strings."""
    urls = []
    url_pattern = re.compile(r'https?://[^\s<>"\')]+')
    
    for string in strings_list:
        for url in url_pattern.findall(string):
            # Filter out benign URLs to reduce false positives
            is_benign = False
            for benign_url in BENIGN_CONTEXTS:
                if benign_url in url:
                    is_benign = True
                    break
            
            if not is_benign:
                urls.append(url)
    
    return urls

def extract_ip_addresses(strings_list):
    """Extract IP addresses from strings."""
    ip_addresses = []
    # Updated regex to be more precise about IPv4 addresses
    ip_pattern = re.compile(r'\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b')
    
    for string in strings_list:
        for ip in ip_pattern.findall(string):
            # Filter common non-suspicious IPs
            if ip not in ["0.0.0.0", "127.0.0.1", "255.255.255.255"]:
                # Check if it's a version number (1.0.0.0, 6.0.0.0, etc.)
                if re.match(r'^[1-9]\.0\.0\.0$', ip) or ip == "6.0.0.0":
                    continue
                # Additional filtering for IPs that look like version numbers or object IDs
                if re.match(r'^\d\.\d+\.\d+\.\d+$', ip):
                    continue
                ip_addresses.append(ip)
    
    return ip_addresses

def find_file_extension_clues(strings_list):
    """Identify strings that might represent target file extensions for encryption."""
    found_extensions = []
    
    for string in strings_list:
        # Check for suspicious extensions
        for ext, weight in FILE_EXTENSIONS.items():
            if ext in string:
                found_extensions.append(f"File Extension Target: {ext}")
                
        # Don't count benign extensions as suspicious
        for ext in BENIGN_EXTENSIONS:
            if ext in string:
                # These are normal and shouldn't contribute to the score
                pass
    
    return found_extensions

def analyze_pe_file(file_path):
    """Analyze PE file for suspicious characteristics."""
    if not PE_SUPPORT:
        return 0, [], [], False
    
    pe_score = 0
    imported_functions = []
    named_sections = []
    is_executable_file = True
    
    suspicious_imports = [
        "CryptEncrypt", "VirtualProtect", "WriteFile", 
        "CreateFile", "SetFilePointer", "ReadFile",
        "FindFirstFile", "FindNextFile", "GetTempPath"
    ]
    
    suspicious_sections = [
        ".rsrc", ".data", ".rdata", ".text", ".reloc"
    ]
    
    try:
        pe_obj = portable_executable.PE(file_path)
        
        # Check imports
        if hasattr(pe_obj, 'DIRECTORY_ENTRY_IMPORT'):
            for entry in pe_obj.DIRECTORY_ENTRY_IMPORT:
                dll_name = entry.dll.decode('utf-8', errors='ignore') if entry.dll else "unknown"
                
                for imp in entry.imports:
                    if imp.name:
                        func_name = imp.name.decode('utf-8', errors='ignore')
                        for susp_import in suspicious_imports:
                            if susp_import in func_name:
                                imported_functions.append(f"{dll_name}:{func_name}")
                                pe_score += 1
        
        # Check sections
        for section in pe_obj.sections:
            section_name = section.Name.decode('utf-8', errors='ignore').strip('\x00')
            # Check if section has execute + write permissions (suspicious)
            if section.Characteristics & 0xE0000000 == 0xE0000000:
                named_sections.append(f"{section_name} (Executable+Writable)")
                pe_score += 2
            
            # Check for unusually high entropy in sections
            section_data = section.get_data()
            if section_data:
                # Calculate section entropy
                entropy = 0
                for byte_value in range(256):
                    p_x = section_data.count(bytes([byte_value])) / len(section_data)
                    if p_x > 0:
                        entropy += - p_x * math.log2(p_x)
                        
                if entropy > 7.5:  # Very high entropy section
                    named_sections.append(f"{section_name} (High Entropy: {entropy:.4f})")
                    pe_score += 1
        
        # Check if the file is actually executable
        is_executable_file = False
        for section in pe_obj.sections:
            if section.Characteristics & 0x20000000:  # IMAGE_SCN_MEM_EXECUTE
                is_executable_file = True
                break
                
        pe_obj.close()

    except portable_executable.PEFormatError:
        is_executable_file = False
    except Exception as e:
        print(f"  Error during PE file analysis of {file_path}: {e}", file=sys.stderr)
        pe_score = 0
        imported_functions = []
        named_sections = []

    return pe_score, imported_functions, named_sections, is_executable_file

def analyze_single_item(file_location):
    """Performs static analysis on a given file and returns an overall score and indicators."""
    print(f"\n--- Examining: {file_location} ---")
    total_score = 0
    identified_indicators = []

    try:
        if not os.path.isfile(file_location):
            print("  Problem: Not a valid file.", file=sys.stderr)
            return 0, []
        if not os.access(file_location, os.R_OK):
            print("  Problem: File not readable.", file=sys.stderr) 
            return 0, []
            
        # Calculate file entropy
        entropy = get_entropy(file_location)
        print(f"  Entropy Level: {entropy:.4f}")
        
        # Very high entropy (> 7.7) is suspicious and might indicate encryption
        if entropy > 7.7:
            total_score += 2
            identified_indicators.append(f"Elevated Entropy ({entropy:.4f})")
        
        # Extract strings
        strings_list = extract_strings(file_location)
        
        # Find suspicious keywords
        found_keywords, suspicious_contexts = find_suspicious_keywords(strings_list)
        
        # Extract URLs and IPs
        found_urls = extract_urls(strings_list)
        found_ips = extract_ip_addresses(strings_list)
        
        # Find file extension clues
        found_extensions = find_file_extension_clues(strings_list)
        
        # Analyze PE structure if it's an executable
        pe_score, imported_functions, named_sections, is_executable = analyze_pe_file(file_location)
        
        # Combine all indicators
        identified_indicators.extend(found_keywords)
        identified_indicators.extend(suspicious_contexts)
        identified_indicators.extend([f"URL Found: {url}" for url in found_urls[:5]])  # Limit to prevent overwhelming output
        identified_indicators.extend([f"IP Address Found: {ip}" for ip in found_ips[:5]])  # Limit to prevent overwhelming output
        identified_indicators.extend(found_extensions)
        identified_indicators.extend([f"Suspicious Import: {imp}" for imp in imported_functions])
        identified_indicators.extend([f"Suspicious Section: {sec}" for sec in named_sections])
        
        # Calculate total score with better weighting
        # Keywords have varying weights based on risk level
        keyword_score = 0
        for indicator in found_keywords:
            keyword = indicator.replace("Keyword Match: ", "")
            for risk_level, keywords in KEYWORD_WEIGHTS.items():
                for kw, weight in keywords.items():
                    clean_kw = kw.replace('_', ' ')
                    if clean_kw == keyword.lower():
                        keyword_score += weight
                        break
        
        # Score calculation based on weighted factors
        total_score += keyword_score
        total_score += len(suspicious_contexts) * 2  # Suspicious contexts are stronger indicators
        total_score += len(found_urls) * 0.5  # URLs are weak indicators
        total_score += len(found_ips) * 0.5   # IPs are weak indicators
        
        # Extension clues are moderately strong indicators
        for ext_indicator in found_extensions:
            for ext, weight in FILE_EXTENSIONS.items():
                if ext in ext_indicator:
                    total_score += weight
                    
        # PE analysis score
        total_score += pe_score
        
        # Limit and clean the indicators list for display
        if len(identified_indicators) > 10:
            print(f"  Suspicious Strings Found: {len(identified_indicators)}")
            # Truncate the list for display
            display_indicators = identified_indicators[:10]
            remaining = len(identified_indicators) - 10
            if remaining > 0:
                display_indicators.append(f"... and {remaining} more.")
        else:
            print(f"  Suspicious Strings Found: {len(identified_indicators)}")
            display_indicators = identified_indicators
            
        # Output the results
        print(f"  Total Score: {int(total_score)} (Threshold: {DETECTION_THRESHOLD})")
        
        if identified_indicators:
            print("  Detected Indicators:")
            for indicator in display_indicators:
                print(f"    - {indicator}")
        
        # Final determination
        outcome = "Positive" if total_score >= DETECTION_THRESHOLD else "Negative"
        print(f"  Analysis Outcome: {outcome}")
        
        return total_score, identified_indicators
        
    except Exception as e:
        print(f"  Error analyzing {file_location}: {str(e)}", file=sys.stderr)
        return 0, []

def analyze_directory(directory_path, recursive=True):
    """Recursively analyzes all files in a directory."""
    print(f"--- Scanning Directory{' (Recursive)' if recursive else ''}: {directory_path} ---\n")
    
    try:
        for item in os.listdir(directory_path):
            full_path = os.path.join(directory_path, item)
            
            if os.path.isfile(full_path):
                analyze_single_item(full_path)
            elif os.path.isdir(full_path) and recursive:
                analyze_directory(full_path, recursive)
    
    except PermissionError:
        print(f"Permission denied when accessing: {directory_path}", file=sys.stderr)
    except Exception as e:
        print(f"Error scanning directory {directory_path}: {str(e)}", file=sys.stderr)

def main():
    """Main function to handle command line arguments and run analysis."""
    print("============================================================")
    print(" Static Ransomware Detector POC")
    print(f" Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    
    if len(sys.argv) < 2:
        print("Usage: python static_detector.py <file_or_directory_path>")
        sys.exit(1)
    
    target_path = sys.argv[1]
    print(f" Target: {os.path.abspath(target_path)}")
    print("============================================================")
    
    # Check if the path exists
    if not os.path.exists(target_path):
        print(f"Error: The path '{target_path}' does not exist.", file=sys.stderr)
        sys.exit(1)
    
    # Analyze based on whether it's a file or directory
    if os.path.isfile(target_path):
        analyze_single_item(target_path)
    elif os.path.isdir(target_path):
        analyze_directory(target_path, recursive=True)
    else:
        print(f"Error: The path '{target_path}' is neither a file nor a directory.", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()