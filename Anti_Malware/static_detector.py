import os
import subprocess
import math
import collections
import argparse
import sys
import re # Added for regex checks like IPs
from datetime import datetime  # Add this import at the top of your script

# --- Main Execution Logic ---
if __name__ == "__main__":
    ...
    print("="*60)
    print(f" Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")  # Added timestamp

# Attempt to import pefile, provide guidance if missing
try:
    import pefile
except ImportError:
    print("Error: 'pefile' library not found.", file=sys.stderr)
    print("Please install it using: pip install pefile", file=sys.stderr)
    sys.exit(1)

# --- Configuration & Indicators (Expanded based on the document) ---

# Entropy threshold - This needs calibration based on testing!
# Values between 6.0 and 8.0 are often considered high/suspicious.
HIGH_ENTROPY_THRESHOLD = 7.0 # 

# Scoring weights - These are examples and need significant tuning!
SCORE_WEIGHTS = {
    "HIGH_ENTROPY": 2,
    "SUSPICIOUS_IMPORT": 1,
    "SUSPICIOUS_SECTION": 2,
    "SUSPICIOUS_STRING_KEYWORD": 1,
    "SUSPICIOUS_STRING_COMMAND": 2,
    "SUSPICIOUS_STRING_EXTENSION": 1,
    "SUSPICIOUS_STRING_IP_URL": 1,
}

# Final threshold score to classify as 'Positive' - Needs tuning!
DETECTION_THRESHOLD = 5 # Example threshold

# Indicator Lists based on "Help For The Hopeless" document

# Suspicious DLL Imports
SUSPICIOUS_DLLS = {
    # Crypto
    "advapi32.dll", "bcrypt.dll", "ncrypt.dll", "crypt32.dll", "wincrypt.h",
    # File system enumeration
    "kernel32.dll", "shell32.dll", "shlwapi.dll", "ntdll.dll", "ole32.dll",
    # Internet requests
    "wininet.dll", "winhttp.dll", "ws2_32.dll", "urlmon.dll", "httpapi.dll", "dnsapi.dll",
    # Other potentially relevant
    "user32.dll", # Often used, but involved in many operations
    "shell32.dll",
    "gdi32.dll"
}

# Suspicious Function Imports
SUSPICIOUS_FUNCTIONS = {
    # Dynamic Loading / Evasion
    "LoadLibrary", "GetProcAddress",
    # File Enumeration/Access
    "FindFirstFile", "FindNextFile", "FindClose", "CreateFile", "ReadFile", "WriteFile",
    "DeleteFile", "RemoveDirectory", "SetFileAttributes", "GetLogicalDrives", "GetDriveType",
    # CryptoAPI / CNG
    "CryptAcquireContext", "CryptGenKey", "CryptEncrypt", "CryptDecrypt",
    "BCryptEncrypt", "BCryptGenRandom",
    # Networking / C2 Communication
    "InternetOpen", "InternetConnect", "HttpOpenRequest", "HttpSendRequest",
    "WinHttpOpen", "WinHttpConnect", "WinHttpSendRequest",
    "socket", "connect", "send", "recv", "URLDownloadToFile",
    # Process/Memory Manipulation / Injection / Evasion
    "OpenProcess", "VirtualAlloc", "VirtualAllocEx", "WriteProcessMemory", "ReadProcessMemory",
    "CreateRemoteThread", "AdjustTokenPrivileges", "OpenProcessToken",
    # Anti-Debugging / Anti-Analysis
    "IsDebuggerPresent", "CheckRemoteDebuggerPresent", "NtQueryInformationProcess",
    "GetTickCount", "QueryPerformanceCounter", "RDTSC", "Sleep", "NtDelayExecution",
    # Persistence / System Modification
    "RegOpenKey", "RegSetValue", "RegCreateKey",
    "CreateService", "OpenService", "StartService", "CopyFile", # Check for specific paths later
    # Destructive Actions / Commands
    "system", "ShellExecute", "CreateProcess", # Context matters here
    "DeleteVolumeMountPoint", "DeviceIoControl",
}

# Suspicious static strings (Keywords)
SUSPICIOUS_KEYWORDS = [
    b"encrypt", b"decrypt", b"ransom", b"bitcoin", b"locked", b"wallet",
    b"recover", b"restore", b"attacked", b"hack", b"payment", b"deadline",
    b"contact", b"email", b"tor ", b".onion", b"AES", b"RSA", b"cipher",
    # Ransom note phrases from document
    b"pay", b"disk", b"if", b"before", b"delete",
]

# Suspicious static strings (Commands)
SUSPICIOUS_COMMANDS = [
    b"vssadmin delete shadows",
    b"bcdedit /set {default} recoveryenabled no",
    b"cipher /w",
    # Other common ones
    b"wmic.exe shadowcopy delete",
    b"wbadmin delete catalog",
    b"taskkill /f /im", # Often used to kill security software/backups
    b"net stop", # To stop services
    b"wevtutil cl", # Clear event logs
]

# Suspicious static strings (File Extension Patterns in ransom notes or code)
SUSPICIOUS_EXTENSIONS_PATTERNS = [
    b".locked", b".encrypted", b".crypt", b".fun", b".payforunlock", b".enc",
    b".key", b".wallet", b".harma", b".wannacry", b".cerber", b".thor", b".locky",
    # Generic indicators
    b".txt", b".doc", b".xls", b".pdf", b".jpg", b".png", # Presence of many common extensions could be part of targeting logic
]

# Standard PE Section Names (used to detect deviations)
STANDARD_SECTION_NAMES = {
    ".text", ".rdata", ".edata", ".tls",
    ".data", ".rodata", ".rsrc", ".pdata",
    ".bss", ".idata", ".reloc", ".CRT",
    # Common compiler/linker sections
    ".code", ".DATA", ".BSS", ".reloc", ".CODE", ".gfids", ".giats", ".gljmp",
    ".orpc", ".shdata", ".srdata", ".stab", ".stabstr", ".sxdata", "_winmajor",
    "_winminor", "_major", "_minor",
}

# --- Analysis Functions ---

def calculate_entropy(file_path):
    """Calculates the Shannon entropy of a file's content."""
    try:
        with open(file_path, 'rb') as f:
            byte_arr = f.read()
        if not byte_arr:
            return 0.0, 0 # Return 0 entropy and 0 score contribution

        file_size = len(byte_arr)
        freq_list = collections.Counter(byte_arr)
        entropy = 0.0
        for freq in freq_list.values():
            prob = freq / file_size
            entropy -= prob * math.log2(prob)

        score_contribution = 0
        indicator_str = ""
        if entropy >= HIGH_ENTROPY_THRESHOLD:
            score_contribution = SCORE_WEIGHTS["HIGH_ENTROPY"]
            indicator_str = f"High Entropy ({entropy:.4f})"

        return entropy, score_contribution, indicator_str

    except FileNotFoundError:
        print(f"Warning: File not found during entropy calculation: {file_path}", file=sys.stderr)
        return 0.0, 0, ""
    except Exception as e:
        print(f"Error calculating entropy for {file_path}: {e}", file=sys.stderr)
        return 0.0, 0, "" # Return neutral value on error

def check_strings(file_path):
    """Extracts strings and checks for suspicious keywords/patterns using 'strings' command."""
    # Using subprocess to invoke "strings"
    strings_score = 0
    indicators = []
    try:
        # Use '-a' to scan the entire file, adjust path to 'strings' if needed
        process = subprocess.run(['strings', '-a', file_path], capture_output=True, check=False, timeout=30)

        if process.returncode != 0 and process.stderr:
             # Don't print stderr if it's just about binary file format warnings
             if b'supported format' not in process.stderr.lower():
                 print(f"Warning: 'strings' command returned code {process.returncode} for {file_path}. Stderr: {process.stderr.decode(errors='ignore')}", file=sys.stderr)

        if process.stdout:
            output_lower = process.stdout.lower()
            # Check Keywords 
            for keyword in SUSPICIOUS_KEYWORDS:
                if keyword.lower() in output_lower:
                    indicators.append(f"Keyword: {keyword.decode(errors='ignore')}")
                    strings_score += SCORE_WEIGHTS["SUSPICIOUS_STRING_KEYWORD"]

            # Check Commands 
            for command in SUSPICIOUS_COMMANDS:
                 if command.lower() in output_lower:
                    indicators.append(f"Command: {command.decode(errors='ignore')}")
                    strings_score += SCORE_WEIGHTS["SUSPICIOUS_STRING_COMMAND"]

            # Check Extension Patterns 
            # Simple check, could be refined (e.g., count occurrences)
            ext_count = 0
            for ext_pattern in SUSPICIOUS_EXTENSIONS_PATTERNS:
                 if ext_pattern.lower() in output_lower:
                    if ext_count < 5: # Limit reporting noise
                       indicators.append(f"Extension Pattern: {ext_pattern.decode(errors='ignore')}")
                       strings_score += SCORE_WEIGHTS["SUSPICIOUS_STRING_EXTENSION"]
                    ext_count +=1
            if ext_count >=5 :
                 indicators.append(f"Multiple ({ext_count}) Extension Patterns Found")
                 strings_score += SCORE_WEIGHTS["SUSPICIOUS_STRING_EXTENSION"] # Add score once if many found


            # Check for IPs/URLs (basic regex) 
            # This is very basic and can have false positives/negatives
            ip_pattern = rb'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b'
            url_pattern = rb'https?://[^\s/$.?#].[^\s]*'
            onion_pattern = rb'[a-z2-7]{16,56}\.onion'

            ips_found = re.findall(ip_pattern, process.stdout)
            urls_found = re.findall(url_pattern, process.stdout, re.IGNORECASE)
            onions_found = re.findall(onion_pattern, process.stdout, re.IGNORECASE)

            if ips_found:
                 # Filter out common local/private IPs if desired
                 for ip in ips_found[:3]: # Limit reporting noise
                    indicators.append(f"IP Address: {ip.decode(errors='ignore')}")
                    strings_score += SCORE_WEIGHTS["SUSPICIOUS_STRING_IP_URL"]
            if urls_found:
                 for url in urls_found[:3]:
                     indicators.append(f"URL: {url.decode(errors='ignore')}")
                     strings_score += SCORE_WEIGHTS["SUSPICIOUS_STRING_IP_URL"]
            if onions_found:
                 for onion in onions_found[:3]:
                     indicators.append(f"Onion URL: {onion.decode(errors='ignore')}")
                     strings_score += SCORE_WEIGHTS["SUSPICIOUS_STRING_IP_URL"] * 2 # Higher score for .onion


    except FileNotFoundError:
        print(f"Warning: 'strings' command not found. String analysis skipped for {file_path}.", file=sys.stderr)
    except subprocess.TimeoutExpired:
         print(f"Warning: 'strings' command timed out for {file_path}.", file=sys.stderr)
    except Exception as e:
        print(f"Error running 'strings' on {file_path}: {e}", file=sys.stderr)

    return strings_score, indicators

def analyze_pe_file(file_path):
    """Analyzes PE files (executables/DLLs) for suspicious imports and sections using pefile."""
    # Using pefile library
    pe_score = 0
    import_indicators = []
    section_indicators = []
    is_executable = False

    try:
        pe = pefile.PE(file_path, fast_load=True) # fast_load is faster but might miss some details
        is_executable = pe.is_executable() or pe.is_dll()

        if not is_executable:
            pe.close()
            return 0, [], [], False # Not a PE file we analyze imports/sections for

        # 1. Check Imported Functions 
        # Ensure imports are parsed. Parsing only IMAGE_DIRECTORY_ENTRY_IMPORT.
        pe.parse_data_directories(directories=[pefile.DIRECTORY_ENTRY['IMAGE_DIRECTORY_ENTRY_IMPORT']])
        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
            for entry in pe.DIRECTORY_ENTRY_IMPORT:
                dll_name = entry.dll.decode('utf-8', errors='ignore').lower()
                # Optional: Score based on suspicious DLL name itself?
                # if dll_name in SUSPICIOUS_DLLS:
                #     pass # Add score if needed

                for imp in entry.imports:
                    if imp.name:
                        func_name = imp.name.decode('utf-8', errors='ignore')
                        if func_name in SUSPICIOUS_FUNCTIONS:
                             import_indicators.append(f"Function: {func_name} (from {dll_name})")
                             pe_score += SCORE_WEIGHTS["SUSPICIOUS_IMPORT"]

        # 2. Check Section Names 
        for section in pe.sections:
            try:
                section_name = section.Name.decode('utf-8', errors='ignore').rstrip('\x00')
                # Check if the name is non-standard and not empty
                if section_name and section_name not in STANDARD_SECTION_NAMES:
                    # Further checks could be added (e.g., high entropy sections, executable sections beyond .text)
                    section_indicators.append(f"Name: {section_name}")
                    pe_score += SCORE_WEIGHTS["SUSPICIOUS_SECTION"]
            except Exception as e:
                 print(f"Warning: Could not decode section name in {file_path}: {e}", file=sys.stderr)


        pe.close()

    except pefile.PEFormatError:
        # Expected for non-PE files, not an error in this context
        is_executable = False
        pass
    except Exception as e:
        print(f"Error analyzing PE file {file_path}: {e}", file=sys.stderr)
        # Reset score/indicators on error during PE parsing? Or keep partial results? Decide based on policy.
        pe_score = 0
        import_indicators = []
        section_indicators = []

    return pe_score, import_indicators, section_indicators, is_executable

def analyze_file(file_path):
    """Performs static analysis on a single file and returns a score and indicators."""
    print(f"\n--- Analyzing: {file_path} ---")
    total_score = 0
    all_indicators = []

    try:
        # Check file existence and readability
        if not os.path.isfile(file_path):
             print("  Error: Not a valid file.", file=sys.stderr)
             return 0, []
        if not os.access(file_path, os.R_OK):
             print("  Error: Cannot read file (permissions?).", file=sys.stderr)
             return 0, []


        # 1. Entropy Check 
        entropy, entropy_score, entropy_indicator = calculate_entropy(file_path)
        print(f"  Entropy: {entropy:.4f}")
        if entropy_indicator:
            all_indicators.append(entropy_indicator)
            total_score += entropy_score

        # 2. String Analysis 
        strings_score, string_indicators = check_strings(file_path)
        if string_indicators:
            print(f"  Suspicious Strings Found: {len(string_indicators)}")
            all_indicators.extend(string_indicators)
            total_score += strings_score

        # 3. PE File Analysis (if applicable) 
        pe_score, import_indicators, section_indicators, is_pe = analyze_pe_file(file_path)
        if is_pe:
            print("  Detected as PE file (Executable/DLL)")
            if import_indicators:
                print(f"  Suspicious Imports Found: {len(import_indicators)}")
                all_indicators.extend(import_indicators)
            if section_indicators:
                print(f"  Suspicious Sections Found: {len(section_indicators)}")
                all_indicators.extend(section_indicators)
            total_score += pe_score # Already calculated within analyze_pe_file
        #else:
        #    print("  Not a standard PE file.") # Less verbose output

    except Exception as e:
         print(f"  FATAL ERROR analyzing file {file_path}: {e}", file=sys.stderr)
         # Return 0 score on major error during analysis of a single file
         return 0, [f"Analysis Error: {e}"]


    # --- Result for the file ---
    is_suspicious = total_score >= DETECTION_THRESHOLD
    result = "Positive" if is_suspicious else "Negative"
    print(f"  Score: {total_score} (Threshold: {DETECTION_THRESHOLD})")
    if all_indicators:
        print("  Indicators Found:")
        for ind in all_indicators[:10]: # Print first 10 indicators
             print(f"    - {ind}")
        if len(all_indicators) > 10:
             print(f"    - ... and {len(all_indicators)-10} more.")
    else:
         print("  No specific indicators found.")

    print(f"  File Result: {result}")
    return total_score, all_indicators # Return score and indicators for potential aggregation


# --- Main Execution Logic ---

if __name__ == "__main__":
    parser = argparse.ArgumentParser(
        description="Static Anti-Ransomware Detector POC based on 'Help For The Hopeless' document.",
        epilog="WARNING: Use only in safe, isolated environments. Results require careful interpretation and calibration."
    )
    parser.add_argument("path", help="Path to the file or directory to scan.")
    args = parser.parse_args()

    input_path = args.path
    overall_detection = False
    files_scanned = 0
    detections_found = 0

    if not os.path.exists(input_path):
        print(f"Error: Input path not found: {input_path}", file=sys.stderr)
        sys.exit(1)

    print("="*60)
    print(" Static Ransomware Detector POC")
    print(f" Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}") # Added timestamp
    print(f" Target: {os.path.abspath(input_path)}")
    print("="*60)

    if os.path.isfile(input_path):
        files_scanned += 1
        score, indicators = analyze_file(input_path)
        if score >= DETECTION_THRESHOLD:
            detections_found += 1
            overall_detection = True

    elif os.path.isdir(input_path):
        print(f"--- Scanning Directory (Recursive): {input_path} ---")
        for root, _, files in os.walk(input_path):
            for file in files:
                file_path = os.path.join(root, file)
                # Optional: Add file size limits or skip specific extensions here if needed
                # if os.path.getsize(file_path) > MAX_FILE_SIZE: continue
                # if file.endswith(('.log', '.tmp')): continue
                try:
                    files_scanned += 1
                    score, indicators = analyze_file(file_path)
                    if score >= DETECTION_THRESHOLD:
                        detections_found += 1
                        overall_detection = True
                        # Optional: Stop scanning directory after first detection?
                        # print("\nStopping scan after first detection.")
                        # break # Breaks inner loop (files)
                except OSError as e:
                     print(f"  Error accessing {file_path}: {e}", file=sys.stderr)
                except Exception as e:
                    # Catch unexpected errors during file processing
                    print(f"  Unexpected error analyzing {file_path}: {e}", file=sys.stderr)
            #if overall_detection: # Optional: Check if need to break outer loop
            #    break

    else:
        print(f"Error: Input path is not a valid file or directory: {input_path}", file=sys.stderr)
        sys.exit(1)

    print("\n" + "="*60)
    print(" Scan Summary")
    print("="*60)
    print(f" Files Scanned: {files_scanned}")
    print(f" Detections ('Positive' Files): {detections_found}")
    print("-" * 60)
    if overall_detection:
        print(" Overall Result: Ransomware indicators DETECTED in one or more files.")
        print("                 Review the analysis logs above for details.")
    else:
        print(" Overall Result: No files exceeded the detection threshold.")
        print("                 (This does not guarantee safety - static analysis has limitations).")
    print("="*60)
    print(" Reminder: This is a proof-of-concept. Thresholds and indicators require tuning.")
    print(" Use in a safe environment. ")
    print("="*60)